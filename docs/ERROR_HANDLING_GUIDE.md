# ì—ëŸ¬ ì²˜ë¦¬ ì‹œìŠ¤í…œ ê°€ì´ë“œ

## ğŸ“– ëª©ì°¨

1. [ê°œìš”](#ê°œìš”)
2. [ì—ëŸ¬ ê³„ì¸µ êµ¬ì¡°](#ì—ëŸ¬-ê³„ì¸µ-êµ¬ì¡°)
3. [Repository ì—ëŸ¬ ì‹œìŠ¤í…œ](#repository-ì—ëŸ¬-ì‹œìŠ¤í…œ)
4. [ì—ëŸ¬ ì²˜ë¦¬ ì›Œí¬í”Œë¡œìš°](#ì—ëŸ¬-ì²˜ë¦¬-ì›Œí¬í”Œë¡œìš°)
5. [ì‹¤ì „ ì˜ˆì œ ëª¨ìŒ](#ì‹¤ì „-ì˜ˆì œ-ëª¨ìŒ)
6. [ëª¨ë²” ì‚¬ë¡€ ë° ì•ˆí‹°íŒ¨í„´](#ëª¨ë²”-ì‚¬ë¡€-ë°-ì•ˆí‹°íŒ¨í„´)
7. [ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…](#ëª¨ë‹ˆí„°ë§-ë°-ë¡œê¹…)

---

## ê°œìš”

MeetHere APIëŠ” **ê³„ì¸µë³„ ì—ëŸ¬ ì²˜ë¦¬ ì „ëµ**ì„ í†µí•´ ì•ˆì •ì ì´ê³  ì‚¬ìš©ì ì¹œí™”ì ì¸ ì—ëŸ¬ ê´€ë¦¬ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

### ğŸ¯ ì„¤ê³„ ì›ì¹™

1. **ê³„ì¸µë³„ ì±…ì„ ë¶„ë¦¬**: ê° ê³„ì¸µì€ í•´ë‹¹ ìˆ˜ì¤€ì˜ ì—ëŸ¬ë§Œ ì²˜ë¦¬
2. **íƒ€ì… ì•ˆì „ì„±**: TypeScriptë¥¼ í™œìš©í•œ ì»´íŒŒì¼ ì‹œì  ì—ëŸ¬ ê²€ì¦
3. **ì‚¬ìš©ì ì¤‘ì‹¬**: ê°œë°œìì™€ ìµœì¢… ì‚¬ìš©ì ëª¨ë‘ë¥¼ ê³ ë ¤í•œ ì—ëŸ¬ ë©”ì‹œì§€
4. **ì¶”ì  ê°€ëŠ¥ì„±**: ì—ëŸ¬ ë°œìƒ ì§€ì ë¶€í„° ìµœì¢… ì‘ë‹µê¹Œì§€ ì™„ì „í•œ ì¶”ì 
5. **ë³µêµ¬ ê°€ëŠ¥ì„±**: ê°€ëŠ¥í•œ ê²½ìš° ìë™ ë³µêµ¬ ë° ëŒ€ì²´ ë™ì‘ ì œê³µ

### ğŸ—ï¸ ì „ì²´ ì—ëŸ¬ ì²˜ë¦¬ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Client Request                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Controller Layer                                 â”‚
â”‚  â€¢ HTTP ìƒíƒœ ì½”ë“œ ë§¤í•‘                                            â”‚
â”‚  â€¢ ìš”ì²­ ê²€ì¦ ì—ëŸ¬ ì²˜ë¦¬ (Zod)                                      â”‚
â”‚  â€¢ asyncHandlerë¡œ ìë™ ì—ëŸ¬ ì „íŒŒ                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Service Layer                                   â”‚
â”‚  â€¢ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì—ëŸ¬ ì²˜ë¦¬                                        â”‚
â”‚  â€¢ Repository ì—ëŸ¬ ë³€í™˜                                          â”‚
â”‚  â€¢ ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ ìƒì„±                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Repository Layer                                  â”‚
â”‚  â€¢ ë°ì´í„° ì ‘ê·¼ ì—ëŸ¬ ì²˜ë¦¬                                          â”‚
â”‚  â€¢ ì™¸ë¶€ API ì—ëŸ¬ ë§¤í•‘                                            â”‚
â”‚  â€¢ ìºì‹œ/DB ì—°ê²° ì—ëŸ¬ ê´€ë¦¬                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Error Handler Middleware                          â”‚
â”‚  â€¢ ëª¨ë“  ì—ëŸ¬ì˜ ìµœì¢… ì²˜ë¦¬                                          â”‚
â”‚  â€¢ í†µì¼ëœ ì‘ë‹µ í˜•ì‹ ìƒì„±                                          â”‚
â”‚  â€¢ ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§ ì—°ë™                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Client Response                                  â”‚
â”‚  â€¢ í‘œì¤€í™”ëœ ì—ëŸ¬ ì‘ë‹µ                                             â”‚
â”‚  â€¢ ì ì ˆí•œ HTTP ìƒíƒœ ì½”ë“œ                                          â”‚
â”‚  â€¢ ê°œë°œ/ìš´ì˜ í™˜ê²½ë³„ ì •ë³´ ì¡°ì ˆ                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ì—ëŸ¬ ê³„ì¸µ êµ¬ì¡°

### ğŸ›ï¸ ê¸°ë³¸ ì—ëŸ¬ í´ë˜ìŠ¤ ê³„ì¸µ

```typescript
Error (JavaScript ê¸°ë³¸)
â””â”€â”€ BaseAppError
    â”œâ”€â”€ AppError (ì¼ë°˜ì ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì—ëŸ¬)
    â””â”€â”€ RepositoryError (ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ ì—ëŸ¬)
        â”œâ”€â”€ EntityNotFoundError
        â”œâ”€â”€ EntityConflictError
        â”œâ”€â”€ EntityValidationError
        â”œâ”€â”€ EntityRelationError
        â”œâ”€â”€ DatabaseConnectionError
        â”œâ”€â”€ QueryExecutionError
        â”œâ”€â”€ TransactionError
        â”œâ”€â”€ CacheError
        â””â”€â”€ PaginationError
```

### ğŸ“Š ì—ëŸ¬ ì†ì„± ë° ë©”íƒ€ë°ì´í„°

```typescript
interface ErrorMetadata {
  // ê¸°ë³¸ ì†ì„±
  name: string;
  message: string;
  statusCode: number;
  code: string;
  isOperational: boolean;

  // Repository ì „ìš© ì†ì„±
  repositoryName?: string;
  operation?: string;

  // ì¶”ê°€ ì •ë³´
  details?: any;
  timestamp?: Date;
  requestId?: string;
  userId?: string;
}
```

### ğŸ¨ ì—ëŸ¬ ì½”ë“œ ì²´ê³„

**íŒ¨í„´**: `{DOMAIN}_{ACTION}_{REASON}`

```typescript
// Repository ê³„ì¸µ
ENTITY_NOT_FOUND        // ì—”í‹°í‹°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ
ENTITY_CONFLICT         // ì¤‘ë³µ ë°ì´í„° ì¶©ëŒ
ENTITY_VALIDATION_ERROR // ë°ì´í„° ê²€ì¦ ì‹¤íŒ¨
DATABASE_CONNECTION_ERROR // DB ì—°ê²° ì‹¤íŒ¨
QUERY_EXECUTION_ERROR   // ì¿¼ë¦¬ ì‹¤í–‰ ì‹¤íŒ¨
CACHE_ERROR            // ìºì‹œ ì‘ì—… ì‹¤íŒ¨

// ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ê³„ì¸µ
INVALID_COORDINATES    // ì˜ëª»ëœ ì¢Œí‘œ
TOO_MANY_PARTICIPANTS  // ì°¸ê°€ì ìˆ˜ ì´ˆê³¼
SESSION_EXPIRED        // ì„¸ì…˜ ë§Œë£Œ
INSUFFICIENT_DATA      // ë°ì´í„° ë¶€ì¡±

// HTTP ê³„ì¸µ
VALIDATION_ERROR       // ìš”ì²­ ê²€ì¦ ì‹¤íŒ¨
UNAUTHORIZED          // ì¸ì¦ ì‹¤íŒ¨
FORBIDDEN             // ê¶Œí•œ ì—†ìŒ
NOT_FOUND             // ë¦¬ì†ŒìŠ¤ ì—†ìŒ
```

---

## Repository ì—ëŸ¬ ì‹œìŠ¤í…œ

### ğŸ”§ ì—ëŸ¬ ìƒì„± ë° ë§¤í•‘

**1. ì§ì ‘ ì—ëŸ¬ ìƒì„±**
```typescript
// ì—”í‹°í‹°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ëŠ” ê²½ìš°
throw new EntityNotFoundError('SubwayStation', stationId, 'SubwayStationRepository');

// ê²€ì¦ ì‹¤íŒ¨
throw new EntityValidationError(
  'MeetingSession',
  [
    { field: 'participants', message: 'ìµœì†Œ 2ëª… ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤', value: 1 },
    { field: 'location', message: 'ìœ íš¨í•œ ì¢Œí‘œê°€ ì•„ë‹™ë‹ˆë‹¤', value: { lat: 91, lng: 181 } }
  ],
  'MeetingPointRepository',
  'create'
);
```

**2. ì—ëŸ¬ ë§¤í•‘ ìœ í‹¸ë¦¬í‹° ì‚¬ìš©**
```typescript
export class SubwayStationRepository {
  async findById(id: string): Promise<SubwayStation | null> {
    try {
      const result = await this.database.query(sql, [id]);
      return result;

    } catch (originalError) {
      // ì¼ë°˜ ì—ëŸ¬ë¥¼ Repository ì—ëŸ¬ë¡œ ìë™ ë³€í™˜
      throw mapToRepositoryError(
        originalError,
        'SubwayStationRepository',
        'findById',
        { searchId: id }
      );
    }
  }
}
```

### ğŸ­ ë„ë©”ì¸ë³„ ì „ìš© ì—ëŸ¬ í´ë˜ìŠ¤

**SubwayStationError**
```typescript
export class SubwayStationService {
  async validateSearchArea(lat: number, lng: number, radius: number) {
    // ì¢Œí‘œ ê²€ì¦
    if (lat < 33.0 || lat > 38.6) {
      throw SubwayStationError.invalidCoordinates(lat, lng);
    }

    // ê²€ìƒ‰ ë°˜ê²½ ê²€ì¦
    if (radius > 10000) {
      throw SubwayStationError.invalidSearchRadius(radius);
    }
  }
}

// ì‚¬ìš©ë²•
try {
  await stationService.validateSearchArea(91.0, 127.0, 1000);
} catch (error) {
  if (error instanceof SubwayStationError) {
    console.log(`ì§€í•˜ì² ì—­ ê²€ìƒ‰ ì˜¤ë¥˜: ${error.message}`);
    console.log(`Repository: ${error.repositoryName}`);
    console.log(`Operation: ${error.operation}`);
  }
}
```

**MeetingPointError**
```typescript
export class MeetingPointService {
  async validateMeetingRequest(participants: ParticipantLocation[]) {
    // ì°¸ê°€ì ìˆ˜ ê²€ì¦
    if (participants.length > 10) {
      throw MeetingPointError.tooManyParticipants(participants.length, 10);
    }

    // ê° ì°¸ê°€ì ì •ë³´ ê²€ì¦
    for (const participant of participants) {
      if (!participant.lat || !participant.lng) {
        throw MeetingPointError.invalidParticipant(
          participant.name,
          'ìœ„ì¹˜ ì •ë³´ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤'
        );
      }
    }
  }
}
```

**NaverApiError**
```typescript
export class NaverApiService {
  async getCachedResult(key: string): Promise<CacheResult> {
    try {
      const cached = await this.repository.getCache(key);

      if (!cached) {
        throw NaverApiError.cacheExpired('reverseGeocode', key);
      }

      return cached;

    } catch (error) {
      if (error.name === 'InvalidKeyFormat') {
        throw NaverApiError.invalidCacheKey('reverseGeocode', key);
      }
      throw error;
    }
  }
}
```

---

## ì—ëŸ¬ ì²˜ë¦¬ ì›Œí¬í”Œë¡œìš°

### ğŸ”„ ê³„ì¸µê°„ ì—ëŸ¬ ì „íŒŒ íë¦„

**Repository â†’ Service â†’ Controller â†’ Error Handler**

```typescript
// 1ï¸âƒ£ Repository Layer: ë°ì´í„° ì ‘ê·¼ ì—ëŸ¬
export class SubwayStationRepository {
  async findById(id: string): Promise<SubwayStation | null> {
    const station = await this.dataSource.findOne({ code: id });

    if (!station) {
      // Repository ê³„ì¸µì—ì„œ êµ¬ì²´ì ì¸ ì—ëŸ¬ ìƒì„±
      throw new EntityNotFoundError('SubwayStation', id, 'SubwayStationRepository');
    }

    return station;
  }
}

// 2ï¸âƒ£ Service Layer: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë° ì—ëŸ¬ ë³€í™˜
export class SubwayStationService {
  async getStationById(id: string): Promise<SubwayStation> {
    try {
      const station = await this.repository.findById(id);
      return station;

    } catch (error) {
      // Repository ì—ëŸ¬ë¥¼ ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ë¡œ ë³€í™˜
      if (isEntityNotFoundError(error)) {
        throw new AppError(
          `ìš”ì²­í•˜ì‹  ì§€í•˜ì² ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì—­ì½”ë“œ: ${id})`,
          404,
          'STATION_NOT_FOUND',
          true,
          { stationId: id }
        );
      }

      // ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬ëŠ” ê·¸ëŒ€ë¡œ ì „íŒŒ
      throw error;
    }
  }
}

// 3ï¸âƒ£ Controller Layer: HTTP ì¸í„°í˜ì´ìŠ¤
export const getStation = asyncHandler(async (req: Request, res: Response) => {
  const { id } = req.params;

  // Serviceì—ì„œ ë°œìƒí•œ ì—ëŸ¬ëŠ” asyncHandlerê°€ ìë™ìœ¼ë¡œ next(error)ë¡œ ì „ë‹¬
  const station = await stationService.getStationById(id);

  res.json({
    success: true,
    data: station,
    timestamp: new Date().toISOString()
  });
});

// 4ï¸âƒ£ Error Handler Middleware: ìµœì¢… ì—ëŸ¬ ì²˜ë¦¬
export const errorHandler = (error: Error, req: Request, res: Response, _next: NextFunction) => {
  let statusCode = 500;
  let code = 'INTERNAL_ERROR';
  let message = 'ì„œë²„ ë‚´ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';

  // Repository ì—ëŸ¬ ì²˜ë¦¬
  if (isRepositoryError(error)) {
    statusCode = error.statusCode;
    code = error.code;
    message = error.message;

    // íŠ¹ì • Repository ì—ëŸ¬ íƒ€ì…ë³„ ì‚¬ìš©ì ë©”ì‹œì§€ ì¡°ì •
    if (error instanceof DatabaseConnectionError) {
      message = 'ì¼ì‹œì ìœ¼ë¡œ ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
    }
  }
  // AppError ì²˜ë¦¬
  else if (error instanceof AppError) {
    statusCode = error.statusCode;
    code = error.code;
    message = error.message;
  }

  // ìµœì¢… ì‘ë‹µ
  res.status(statusCode).json({
    success: false,
    error: code,
    message,
    timestamp: new Date().toISOString(),
    requestId: req.headers['x-request-id'],
    ...(process.env.NODE_ENV === 'development' && {
      details: error.details,
      stack: error.stack
    })
  });
};
```

### ğŸš¨ ì—ëŸ¬ ë³µêµ¬ ì „ëµ

**1. ìë™ ì¬ì‹œë„**
```typescript
export class ResilientNaverApiRepository {
  async reverseGeocode(coordinates: Point, retries = 3): Promise<ReverseGeocodeResult> {
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        return await this.performReverseGeocode(coordinates);

      } catch (error) {
        // ë„¤íŠ¸ì›Œí¬ ì—ëŸ¬ì¸ ê²½ìš° ì¬ì‹œë„
        if (error instanceof NetworkError && attempt < retries) {
          await this.delay(Math.pow(2, attempt) * 1000); // ì§€ìˆ˜ ë°±ì˜¤í”„
          continue;
        }

        // ìµœì¢… ì‹¤íŒ¨
        throw new QueryExecutionError(
          'NaverApiRepository',
          'reverseGeocode',
          undefined,
          error,
          { coordinates, attempts: attempt }
        );
      }
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

**2. ëŒ€ì²´ ë°ì´í„° ì†ŒìŠ¤**
```typescript
export class FallbackMeetingPointRepository {
  constructor(
    private primary: IMeetingPointRepository,
    private fallback: IMeetingPointRepository
  ) {}

  async findById(id: string): Promise<MeetingSession | null> {
    try {
      // ì£¼ ë°ì´í„° ì†ŒìŠ¤ ì‹œë„
      return await this.primary.findById(id);

    } catch (error) {
      if (error instanceof DatabaseConnectionError) {
        try {
          // ëŒ€ì²´ ë°ì´í„° ì†ŒìŠ¤ ì‚¬ìš©
          return await this.fallback.findById(id);

        } catch (fallbackError) {
          // ì–‘ìª½ ëª¨ë‘ ì‹¤íŒ¨ ì‹œ ì›ë³¸ ì—ëŸ¬ì™€ í•¨ê»˜ ë³´ê³ 
          throw new QueryExecutionError(
            'FallbackMeetingPointRepository',
            'findById',
            undefined,
            error,
            { fallbackError: fallbackError.message }
          );
        }
      }

      throw error;
    }
  }
}
```

**3. ë¶€ë¶„ì  ì„±ê³µ ì²˜ë¦¬**
```typescript
export class BatchSubwayStationService {
  async getStationsByIds(ids: string[]): Promise<{
    stations: SubwayStation[];
    errors: Array<{ id: string; error: string }>;
  }> {
    const stations: SubwayStation[] = [];
    const errors: Array<{ id: string; error: string }> = [];

    // ê° IDë³„ë¡œ ê°œë³„ ì²˜ë¦¬
    for (const id of ids) {
      try {
        const station = await this.repository.findById(id);
        if (station) stations.push(station);

      } catch (error) {
        errors.push({
          id,
          error: error instanceof EntityNotFoundError
            ? 'ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'
            : 'ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤'
        });
      }
    }

    // ë¶€ë¶„ì  ì„±ê³µë„ ìœ ìš©í•œ ê²°ê³¼ë¡œ ë°˜í™˜
    return { stations, errors };
  }
}
```

---

## ì‹¤ì „ ì˜ˆì œ ëª¨ìŒ

### ğŸ¯ ì‹œë‚˜ë¦¬ì˜¤ 1: ì§€í•˜ì² ì—­ ê²€ìƒ‰ ì‹¤íŒ¨ ì²˜ë¦¬

```typescript
export class StationSearchController {
  static searchNearbyStations = asyncHandler(async (req: Request, res: Response) => {
    const { lat, lng, radius = 1000, limit = 10 } = req.body;

    try {
      // 1ë‹¨ê³„: ì…ë ¥ ê²€ì¦
      if (typeof lat !== 'number' || typeof lng !== 'number') {
        throw new AppError('ìœ„ë„ì™€ ê²½ë„ëŠ” ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤', 400, 'INVALID_COORDINATES');
      }

      // 2ë‹¨ê³„: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì‹¤í–‰
      const stations = await stationService.searchNearbyStations({
        center: { lat, lng },
        radius,
        limit
      });

      // 3ë‹¨ê³„: ì„±ê³µ ì‘ë‹µ
      res.json({
        success: true,
        data: {
          stations,
          searchCenter: { lat, lng },
          searchRadius: radius,
          resultCount: stations.length
        },
        timestamp: new Date().toISOString()
      });

    } catch (error) {
      // asyncHandlerê°€ ìë™ìœ¼ë¡œ errorHandlerë¡œ ì „ë‹¬
      throw error;
    }
  });
}

// Service ê³„ì¸µì—ì„œì˜ ì„¸ë°€í•œ ì—ëŸ¬ ì²˜ë¦¬
export class StationService {
  async searchNearbyStations(params: SearchParams): Promise<SubwayStation[]> {
    try {
      // ì¢Œí‘œ ìœ íš¨ì„± ê²€ì¦
      this.validateCoordinates(params.center.lat, params.center.lng);

      // ê²€ìƒ‰ ë°˜ê²½ ê²€ì¦
      if (params.radius > 10000) {
        throw new AppError(
          'ê²€ìƒ‰ ë°˜ê²½ì€ 10kmë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
          400,
          'SEARCH_RADIUS_TOO_LARGE',
          true,
          { maxRadius: 10000, requestedRadius: params.radius }
        );
      }

      // Repositoryë¥¼ í†µí•œ ë°ì´í„° ì¡°íšŒ
      const stations = await this.repository.findNearby(
        params.center,
        params.radius,
        params.limit
      );

      // ë¹ˆ ê²°ê³¼ ì²˜ë¦¬
      if (stations.length === 0) {
        throw new AppError(
          'ê²€ìƒ‰ ë²”ìœ„ ë‚´ì— ì§€í•˜ì² ì—­ì´ ì—†ìŠµë‹ˆë‹¤. ê²€ìƒ‰ ë°˜ê²½ì„ ëŠ˜ë ¤ë³´ì„¸ìš”.',
          404,
          'NO_STATIONS_FOUND',
          true,
          { searchParams: params }
        );
      }

      return stations;

    } catch (error) {
      // Repository ì—ëŸ¬ë¥¼ ì ì ˆíˆ ë³€í™˜
      if (isEntityValidationError(error)) {
        throw new AppError(
          'ê²€ìƒ‰ ì¡°ê±´ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤',
          400,
          'INVALID_SEARCH_PARAMS',
          true,
          { validationErrors: error.validationErrors }
        );
      }

      throw error; // ê¸°íƒ€ ì—ëŸ¬ëŠ” ê·¸ëŒ€ë¡œ ì „íŒŒ
    }
  }
}
```

**ì˜ˆìƒ ì‘ë‹µ**:
```json
// ì„±ê³µ ì‹œ
{
  "success": true,
  "data": {
    "stations": [...],
    "searchCenter": { "lat": 37.5665, "lng": 126.9780 },
    "searchRadius": 1000,
    "resultCount": 5
  },
  "timestamp": "2024-03-15T10:30:00.000Z"
}

// ì‹¤íŒ¨ ì‹œ
{
  "success": false,
  "error": "NO_STATIONS_FOUND",
  "message": "ê²€ìƒ‰ ë²”ìœ„ ë‚´ì— ì§€í•˜ì² ì—­ì´ ì—†ìŠµë‹ˆë‹¤. ê²€ìƒ‰ ë°˜ê²½ì„ ëŠ˜ë ¤ë³´ì„¸ìš”.",
  "timestamp": "2024-03-15T10:30:00.000Z",
  "requestId": "req-12345"
}
```

### ğŸ¯ ì‹œë‚˜ë¦¬ì˜¤ 2: ìºì‹œ ì‹¤íŒ¨ ì‹œ ëŒ€ì²´ ë™ì‘

```typescript
export class NaverApiService {
  async reverseGeocode(lat: number, lng: number): Promise<AddressInfo> {
    const coordinates = { lat, lng };
    const startTime = Date.now();

    try {
      // 1ë‹¨ê³„: ìºì‹œ í™•ì¸
      const cached = await this.naverRepository.findCachedReverseGeocode(coordinates);

      if (cached) {
        await this.recordSuccess('reverseGeocode', 0, true); // ìºì‹œ íˆíŠ¸
        return this.transformCachedResult(cached);
      }

    } catch (cacheError) {
      // ìºì‹œ ì—ëŸ¬ëŠ” ë¡œê·¸ë§Œ ë‚¨ê¸°ê³  ê³„ì† ì§„í–‰
      logger.warn('ìºì‹œ ì¡°íšŒ ì‹¤íŒ¨, API ì§ì ‘ í˜¸ì¶œë¡œ ì „í™˜', {
        coordinates,
        error: cacheError.message
      });
    }

    try {
      // 2ë‹¨ê³„: ì‹¤ì œ API í˜¸ì¶œ
      const result = await this.callNaverReverseGeocodeApi(coordinates);
      const responseTime = Date.now() - startTime;

      // 3ë‹¨ê³„: ê²°ê³¼ ìºì‹± (ì‹¤íŒ¨í•´ë„ ë¬´ì‹œ)
      try {
        await this.naverRepository.cacheReverseGeocode({
          coordinates,
          address: result.address,
          roadAddress: result.roadAddress,
          district: result.district
        });
      } catch (cachingError) {
        // ìºì‹± ì‹¤íŒ¨ëŠ” ì‚¬ìš©ìì—ê²Œ ì˜í–¥ ì—†ìŒ
        logger.warn('ê²°ê³¼ ìºì‹± ì‹¤íŒ¨', {
          coordinates,
          error: cachingError.message
        });
      }

      await this.recordSuccess('reverseGeocode', responseTime, false);
      return result;

    } catch (apiError) {
      const responseTime = Date.now() - startTime;
      await this.recordFailure('reverseGeocode', responseTime, apiError);

      // API ì‹¤íŒ¨ ì‹œ ì˜ë¯¸ìˆëŠ” ì—ëŸ¬ ë©”ì‹œì§€ ì œê³µ
      if (apiError.response?.status === 429) {
        throw new AppError(
          'ì¼ì¼ API í˜¸ì¶œ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ë‚´ì¼ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
          429,
          'API_RATE_LIMIT_EXCEEDED'
        );
      }

      if (apiError.response?.status === 401) {
        throw new AppError(
          'ì„œë¹„ìŠ¤ ì¸ì¦ ì˜¤ë¥˜ì…ë‹ˆë‹¤. ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.',
          500,
          'API_AUTHENTICATION_ERROR'
        );
      }

      // ê¸°ë³¸ ì—ëŸ¬ ì²˜ë¦¬
      throw new AppError(
        'ì£¼ì†Œ ë³€í™˜ ì„œë¹„ìŠ¤ì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        503,
        'REVERSE_GEOCODING_FAILED',
        true,
        { coordinates, originalError: apiError.message }
      );
    }
  }

  private async recordSuccess(apiType: string, responseTime: number, fromCache: boolean) {
    await this.naverRepository.recordApiUsage({
      apiType,
      success: true,
      responseTime,
      requestData: { fromCache }
    });
  }

  private async recordFailure(apiType: string, responseTime: number, error: any) {
    await this.naverRepository.recordApiUsage({
      apiType,
      success: false,
      responseTime,
      errorCode: error.code || 'UNKNOWN_ERROR',
      requestData: { errorMessage: error.message }
    });
  }
}
```

### ğŸ¯ ì‹œë‚˜ë¦¬ì˜¤ 3: íŠ¸ëœì­ì…˜ ë¡¤ë°± ë° ë³µêµ¬

```typescript
export class MeetingSessionService {
  async createMeetingSession(request: MeetingPointRequest): Promise<MeetingSession> {
    const sessionId = this.generateSessionId();

    try {
      // 1ë‹¨ê³„: ì…ë ¥ ê²€ì¦
      await this.validateRequest(request);

      // 2ë‹¨ê³„: ì¤‘ê°„ì§€ì  ê³„ì‚°
      const center = await this.calculateCenter(request.participants);

      // 3ë‹¨ê³„: ì£¼ë³€ ì§€í•˜ì² ì—­ ê²€ìƒ‰
      const nearbyStations = await this.findNearbyStations(center, request.options);

      // 4ë‹¨ê³„: í†µê³„ ê³„ì‚°
      const stats = this.calculateStatistics(center, request.participants);

      // 5ë‹¨ê³„: ì„¸ì…˜ ì €ì¥
      const session = await this.meetingRepository.create({
        id: sessionId,
        name: request.name,
        participants: request.participants,
        calculatedCenter: center,
        nearbyStations,
        stats
      });

      return session;

    } catch (error) {
      // ì‹¤íŒ¨ ì‹œ ìƒì„±ëœ ë¦¬ì†ŒìŠ¤ ì •ë¦¬
      await this.cleanup(sessionId, error);

      // ì—ëŸ¬ íƒ€ì…ë³„ ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ ì œê³µ
      if (error instanceof EntityValidationError) {
        throw new AppError(
          'ì…ë ¥í•˜ì‹  ì •ë³´ì— ì˜¤ë¥˜ê°€ ìˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ í™•ì¸í•´ì£¼ì„¸ìš”.',
          400,
          'INVALID_SESSION_DATA',
          true,
          { validationErrors: error.validationErrors }
        );
      }

      if (error instanceof SubwayStationError) {
        throw new AppError(
          'ì¤‘ê°„ì§€ì  ì£¼ë³€ì— ì§€í•˜ì² ì—­ì´ ì—†ìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ìœ„ì¹˜ë¥¼ ì‹œë„í•´ì£¼ì„¸ìš”.',
          404,
          'NO_NEARBY_STATIONS'
        );
      }

      // ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬
      throw new AppError(
        'íšŒì˜ ì„¸ì…˜ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
        500,
        'SESSION_CREATION_FAILED',
        false, // ìš´ì˜ ì—ëŸ¬ë¡œ ë¶„ë¥˜
        { sessionId, originalError: error.message }
      );
    }
  }

  private async cleanup(sessionId: string, error: Error): Promise<void> {
    try {
      // ë¶€ë¶„ì ìœ¼ë¡œ ìƒì„±ëœ ì„¸ì…˜ ì •ë³´ ì‚­ì œ
      await this.meetingRepository.delete(sessionId);

      logger.info('Failed session cleanup completed', {
        sessionId,
        errorType: error.constructor.name,
        errorMessage: error.message
      });

    } catch (cleanupError) {
      // ì •ë¦¬ ì‘ì—… ì‹¤íŒ¨ëŠ” ë¡œê·¸ë§Œ ë‚¨ê¹€
      logger.error('Session cleanup failed', {
        sessionId,
        originalError: error.message,
        cleanupError: cleanupError.message
      });
    }
  }
}
```

---

## ëª¨ë²” ì‚¬ë¡€ ë° ì•ˆí‹°íŒ¨í„´

### âœ… ëª¨ë²” ì‚¬ë¡€ (Best Practices)

**1. ëª…í™•í•œ ì—ëŸ¬ ë©”ì‹œì§€**
```typescript
// âŒ ë‚˜ìœ ì˜ˆ
throw new Error('Invalid data');

// âœ… ì¢‹ì€ ì˜ˆ
throw new EntityValidationError(
  'MeetingSession',
  [
    {
      field: 'participants',
      message: 'ì°¸ê°€ìëŠ” ìµœì†Œ 2ëª…, ìµœëŒ€ 10ëª…ì´ì–´ì•¼ í•©ë‹ˆë‹¤',
      value: participants.length
    }
  ],
  'MeetingPointRepository',
  'create'
);
```

**2. ì—ëŸ¬ íƒ€ì…ë³„ ì ì ˆí•œ ì²˜ë¦¬**
```typescript
// âœ… ì¢‹ì€ ì˜ˆ: ì—ëŸ¬ íƒ€ì…ë³„ ì°¨ë³„í™”ëœ ì²˜ë¦¬
export class MeetingPointController {
  static calculateMeetingPoint = asyncHandler(async (req: Request, res: Response) => {
    try {
      const result = await meetingService.calculateMeetingPoint(req.body);
      res.json({ success: true, data: result });

    } catch (error) {
      // êµ¬ì²´ì ì¸ ì—ëŸ¬ íƒ€ì…ë³„ ì²˜ë¦¬
      if (isEntityValidationError(error)) {
        // ì‚¬ìš©ì ì…ë ¥ ì˜¤ë¥˜ - ìƒì„¸ ì •ë³´ ì œê³µ
        throw new AppError(
          'ì…ë ¥ ì •ë³´ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”',
          400,
          'VALIDATION_FAILED',
          true,
          { validationErrors: error.validationErrors }
        );
      }

      if (error instanceof SubwayStationError) {
        // ì§€í•˜ì² ì—­ ê´€ë ¨ ì˜¤ë¥˜ - ëŒ€ì•ˆ ì œì‹œ
        throw new AppError(
          'ì¤‘ê°„ì§€ì  ì£¼ë³€ì— ì§€í•˜ì² ì—­ì´ ì—†ìŠµë‹ˆë‹¤. ê²€ìƒ‰ ë°˜ê²½ì„ ëŠ˜ë ¤ë³´ì„¸ìš”.',
          404,
          'NO_STATIONS_FOUND'
        );
      }

      // ê¸°íƒ€ ì—ëŸ¬ëŠ” ì „íŒŒ
      throw error;
    }
  });
}
```

**3. ë¡œê¹…ì„ í†µí•œ ë””ë²„ê¹… ì •ë³´ ì œê³µ**
```typescript
// âœ… ì¢‹ì€ ì˜ˆ: ë‹¨ê³„ë³„ ë¡œê¹…
export class NaverApiService {
  async reverseGeocode(coordinates: Point): Promise<AddressInfo> {
    logger.info('ì—­ì§€ì˜¤ì½”ë”© ì‹œì‘', { coordinates });

    try {
      const result = await this.performReverseGeocode(coordinates);

      logger.info('ì—­ì§€ì˜¤ì½”ë”© ì„±ê³µ', {
        coordinates,
        resultAddress: result.address,
        responseTime: result.responseTime
      });

      return result;

    } catch (error) {
      logger.error('ì—­ì§€ì˜¤ì½”ë”© ì‹¤íŒ¨', {
        coordinates,
        errorType: error.constructor.name,
        errorMessage: error.message,
        stack: error.stack
      });

      throw error;
    }
  }
}
```

### âŒ ì•ˆí‹°íŒ¨í„´ (Anti-Patterns)

**1. ì—ëŸ¬ ì •ë³´ ìˆ¨ê¸°ê¸°**
```typescript
// âŒ ë‚˜ìœ ì˜ˆ: ëª¨ë“  ì—ëŸ¬ë¥¼ ì¼ë°˜ì ì¸ ë©”ì‹œì§€ë¡œ ë³€í™˜
catch (error) {
  throw new Error('Something went wrong');
}

// âœ… ì¢‹ì€ ì˜ˆ: ì ì ˆí•œ ìˆ˜ì¤€ì˜ ì •ë³´ ì œê³µ
catch (error) {
  if (error instanceof EntityNotFoundError) {
    throw new AppError(
      `ìš”ì²­í•˜ì‹  ì§€í•˜ì² ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ (ì½”ë“œ: ${error.details.identifier})`,
      404,
      'STATION_NOT_FOUND',
      true,
      { stationCode: error.details.identifier }
    );
  }
  throw error;
}
```

**2. ì—ëŸ¬ ë¬´ì‹œí•˜ê¸°**
```typescript
// âŒ ë‚˜ìœ ì˜ˆ: ì—ëŸ¬ë¥¼ catchí•˜ê³  ë¬´ì‹œ
try {
  await this.cacheResult(data);
} catch {
  // ì—ëŸ¬ ë¬´ì‹œ - ì‚¬ì¼ëŸ°íŠ¸ ì‹¤íŒ¨
}

// âœ… ì¢‹ì€ ì˜ˆ: ì—ëŸ¬ë¥¼ ë¡œê·¸í•˜ê³  ì ì ˆíˆ ì²˜ë¦¬
try {
  await this.cacheResult(data);
} catch (cacheError) {
  logger.warn('ìºì‹± ì‹¤íŒ¨, ì„œë¹„ìŠ¤ëŠ” ì •ìƒ ë™ì‘', {
    data: data.id,
    error: cacheError.message
  });
  // ìºì‹± ì‹¤íŒ¨ëŠ” ì„œë¹„ìŠ¤ ë™ì‘ì— ì˜í–¥ ì—†ìŒ
}
```

**3. ê³¼ë„í•œ try-catch**
```typescript
// âŒ ë‚˜ìœ ì˜ˆ: ëª¨ë“  ë¼ì¸ì„ try-catchë¡œ ê°ì‹¸ê¸°
try {
  const user = await this.getUser(id);
} catch (error) {
  throw error;
}

try {
  const preferences = await this.getPreferences(user.id);
} catch (error) {
  throw error;
}

// âœ… ì¢‹ì€ ì˜ˆ: ì˜ë¯¸ìˆëŠ” ë‹¨ìœ„ë¡œ ë¬¶ì–´ì„œ ì²˜ë¦¬
try {
  const user = await this.getUser(id);
  const preferences = await this.getPreferences(user.id);
  const recommendations = await this.generateRecommendations(user, preferences);

  return recommendations;

} catch (error) {
  // ì „ì²´ ì›Œí¬í”Œë¡œìš° ì‹¤íŒ¨ì— ëŒ€í•œ ì˜ë¯¸ìˆëŠ” ì²˜ë¦¬
  throw new AppError(
    'ì¶”ì²œ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
    500,
    'RECOMMENDATION_FAILED',
    false,
    { userId: id, step: this.identifyFailedStep(error) }
  );
}
```

---

## ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

### ğŸ“Š ì—ëŸ¬ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
export class ErrorMetricsCollector {
  private errorCounts = new Map<string, number>();
  private errorRates = new Map<string, number[]>();

  recordError(error: Error, context: any) {
    const errorType = error.constructor.name;
    const errorCode = (error as any).code || 'UNKNOWN';

    // ì—ëŸ¬ ë°œìƒ íšŸìˆ˜
    this.errorCounts.set(errorType, (this.errorCounts.get(errorType) || 0) + 1);

    // ì‹œê°„ë³„ ì—ëŸ¬ìœ¨ ì¶”ì 
    const currentHour = Math.floor(Date.now() / (1000 * 60 * 60));
    const hourlyErrors = this.errorRates.get(errorType) || [];
    hourlyErrors.push(currentHour);
    this.errorRates.set(errorType, hourlyErrors.slice(-24)); // ìµœê·¼ 24ì‹œê°„ë§Œ ë³´ê´€

    // ë©”íŠ¸ë¦­ ì „ì†¡ (Prometheus, DataDog ë“±)
    this.sendMetric('error.count', 1, {
      error_type: errorType,
      error_code: errorCode,
      repository: context.repository,
      operation: context.operation
    });
  }

  getErrorStats(): ErrorStats {
    return {
      totalErrors: Array.from(this.errorCounts.values()).reduce((a, b) => a + b, 0),
      errorsByType: Object.fromEntries(this.errorCounts),
      errorTrends: this.calculateTrends(),
      topErrors: this.getTopErrors(10)
    };
  }
}
```

### ğŸ” êµ¬ì¡°í™”ëœ ë¡œê¹…

```typescript
export class StructuredLogger {
  error(error: Error, context: LogContext) {
    const logEntry = {
      level: 'error',
      timestamp: new Date().toISOString(),
      message: error.message,
      error: {
        name: error.name,
        code: (error as any).code,
        stack: error.stack,
        isOperational: (error as any).isOperational
      },
      context: {
        requestId: context.requestId,
        userId: context.userId,
        operation: context.operation,
        repository: context.repository,
        metadata: context.metadata
      },
      environment: process.env.NODE_ENV,
      service: 'meet-here-api',
      version: process.env.APP_VERSION
    };

    // êµ¬ì¡°í™”ëœ JSON ë¡œê·¸ ì¶œë ¥
    console.error(JSON.stringify(logEntry));

    // ì™¸ë¶€ ë¡œê¹… ì„œë¹„ìŠ¤ë¡œ ì „ì†¡ (ELK, Splunk ë“±)
    this.sendToExternalLogger(logEntry);

    // ì‹¬ê°í•œ ì—ëŸ¬ëŠ” ì•Œë¦¼ ë°œì†¡
    if (!error.isOperational) {
      this.sendAlert(error, context);
    }
  }
}
```

### ğŸ“ˆ ëŒ€ì‹œë³´ë“œ ë° ì•Œë¦¼

```typescript
export class ErrorAlertManager {
  async checkErrorThresholds() {
    const stats = await this.getHourlyErrorStats();

    // ì—ëŸ¬ìœ¨ì´ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ëŠ” ê²½ìš°
    if (stats.errorRate > 0.05) { // 5% ì´ˆê³¼
      await this.sendAlert({
        type: 'HIGH_ERROR_RATE',
        message: `ì—ëŸ¬ìœ¨ì´ ${(stats.errorRate * 100).toFixed(2)}%ë¡œ ì„ê³„ê°’ì„ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤`,
        details: {
          currentRate: stats.errorRate,
          threshold: 0.05,
          timeWindow: '1 hour',
          topErrors: stats.topErrors
        }
      });
    }

    // íŠ¹ì • Repositoryì—ì„œ ì—°ì† ì‹¤íŒ¨
    const repositoryErrors = await this.getRepositoryErrorCounts();
    for (const [repo, count] of repositoryErrors.entries()) {
      if (count > 100) { // 1ì‹œê°„ì— 100íšŒ ì´ˆê³¼
        await this.sendAlert({
          type: 'REPOSITORY_DEGRADATION',
          message: `${repo}ì—ì„œ ë†’ì€ ì—ëŸ¬ ë°œìƒë¥  ê°ì§€`,
          details: {
            repository: repo,
            errorCount: count,
            timeWindow: '1 hour'
          }
        });
      }
    }
  }
}
```

---

ì´ ì¢…í•©ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ ê°€ì´ë“œë¥¼ í†µí•´ ì•ˆì •ì ì´ê³  ì‚¬ìš©ì ì¹œí™”ì ì¸ APIë¥¼ êµ¬ì¶•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê° ê³„ì¸µì˜ ì±…ì„ì„ ëª…í™•íˆ í•˜ê³ , íƒ€ì… ì•ˆì „í•œ ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í†µí•´ ëŸ°íƒ€ì„ ì˜¤ë¥˜ë¥¼ ìµœì†Œí™”í•˜ë©°, ì ì ˆí•œ ëª¨ë‹ˆí„°ë§ì„ í†µí•´ ì‹œìŠ¤í…œì˜ ê±´ê°•ì„±ì„ ì§€ì†ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ğŸš€